---
title: ctfshow刷题小记-crypto
link: ctfshow-shua-ti-xiao-ji-crypto
date: 2026-02-11 13:43:39
description: 记录下学习密码的过程
texRenderer: true
tags:
  - 密码
  - ctfshow
categories:
  - [笔记, 密码]
---

## crypto4

> p=447685307 q=2053 e=17
>
> 提交 flag{d}即可

这个入门题考察我 rsa 算法（俺不会，先去求助下 ai

---

### RSA 相关公式

- 计算模数 n

$$
n = p \times q
$$

- 计算欧拉函数

$$
\phi(n) = (p-1)(q-1)
$$

- 计算私钥

$$
e \times d \equiv 1 \pmod{\phi(n)}
$$

### 模逆元

求解 $d$ 的本质是求解 $e$ 在模 $\phi(n)$ 下的乘法逆元，也就是说，必须满足 $ed\equiv1\pmod{\phi(n)}$ 

这里需要扩展欧几里德算法进行求解

### 扩展欧几里德算法

先从普通欧几里德算法说起，也就是我们最常见的辗转相除法

```plain
问题：求解gcd(48,18)
48 ÷ 18 = 2 余 12
18 ÷ 12 = 1 余 6  
12 ÷ 6  = 2 余 0  ← 余数为0，停止！
所以gcd(48,18)=6
```

核心思想：`gcd(a,b)=gcd(b,a mod b)`,一直到余数为 0

那么扩展欧几里德的创新点就在于，它不仅能求出`gcd(a,b)`，还能找到两个整数 x 和 y，使得`ax+by=gcd(a,b)`这也叫贝祖等式

举个例子

```plain
问题：求解gcd(48,18),同时找到x,y使得48x+18y=6
步骤1： 48 ÷ 18 = 2 余 12
步骤2： 18 ÷ 12 = 1 余 6  
步骤3： 12 ÷ 6  = 2 余 0  ← 余数为0，停止！
结论：gcd(48,18)=6
```

重点来了，开始回代，从步骤 2 开始

```plain
6 = 18 - 1 x 12
6 = 18 - 1 x (48 - 2 x 18)
整理：6 = -1 x 48 + 3 x 18
因此：48 x (-1) + 18 x 3 = 6 = gcd(48,18) 
```

那么为啥说扩展欧几里德能求模逆元呢？

可以观察到，当 gcd(a,b)=1 时，即 a 和 b 互质，那么我们就能通过扩展欧几里德算法得到*ax*+*by*=1

两边同时*mod b*: *ax≡1(modb)*

 这样就意味着 x 就是 a 在模 b 下的逆元

这时候回到上面的密码题中

```plain
a=e=17
b=ϕ(n)=(p-1)*(q-1)=918650247912
```

因为 e 和ϕ(n)互质(gcd=1),所以存在逆元 d，通过算法，可以得到 17d+yϕ(n)=1，然后这里的 y 对于我们求解 d 作用不大，那么整个问题可以整理转换成利用扩展欧几里德，计算 gcd(e,ϕ(n)),同时求解 d,y 使得 de+yϕ(n)=gcd(e,ϕ(n))

那么开始编写脚本

```python
p = 447685307
q = 2053
e = 17

phi_n= (p-1) * (q-1)
def extended_gcd(a,b):
    if b==0: #递归结束，没有余数
        return a,1,0  
    gcd,x1,y1=extended_gcd(b,a%b)  #这里有递归
    x=y1
    y=x1-(a//b)*y1
    return gcd,x,y
gcd ,x ,y=extended_gcd(e,phi_n)

d=x%phi_n
print(f"flag{{{d}}}")
#flag{594420748649}
```

but，本题其实也不用一定掌握扩展欧几里德，直接求逆元就可以了

- 计算私钥

$$
e \times d \equiv 1 \pmod{\phi(n)}
$$

请看这个公式，稍微变换一下，就是`d=e^-1 (mod ϕ(n))`

```python
p = 447685307
q = 2053
e = 17
phi= (p-1) * (q-1)
d=pow(e,-1,phi)
print(f"flag{{{d}}}")
```

## crypto5

> p=447685307 q=2037 e=17 c=704796792
>
> 提交 flag{m}

上一个题目，我学会求解 d 了，接下来学下，怎么求明文 m

RSA 解密公式
$$
m \equiv c^d \pmod{n}
$$
那么我可以在上一个脚本的基础上,稍微调整即可,然后 python 中有个特别方便的函数 pow(),比如这里要求解 m，我应该写`m=pow(c,d,n)`

```python
p = 447685307
q = 2037
e = 17
c = 704796792

phi_n= (p-1) * (q-1)
def extended_gcd(a,b):
    if b==0:
        return a,1,0
    gcd,x1,y1=extended_gcd(b,a%b)
    x=y1
    y=x1-(a//b)*y1
    return gcd,x,y
gcd ,x ,y=extended_gcd(e,phi_n)

d=x%phi_n
print(f"d: {d}")
m=pow(c,d,p*q)
print(f"flag{{{m}}}")
"""
d: 53616899001
flag{904332399012}
"""
```

## babyrsa

这个题我自己写的，算是把基础的 rsa 算法搞明白了

```python
from Crypto.Util.number import long_to_bytes
e = 65537
p = 104046835712664064779194734974271185635538927889880611929931939711001301561682270177931622974642789920918902563361293345434055764293612446888383912807143394009019803471816448923969637980671221111117965227402429634935481868701166522350570364727873283332371986860194245739423508566783663380619142431820861051179
q = 140171048074107988605773731671018901813928130582422889797732071529733091703843710859282267763783461738242958098610949120354497987945911021170842457552182880133642711307227072133812253341129830416158450499258216967879857581565380890788395068130033931180395926482431150295880926480086317733457392573931410220501
c = 4772758911204771028049020670778336799568778930072841084057809867608022732611295305096052430641881550781141776498904005589873830973301898523644744951545345404578466176725030290421649344936952480254902939417215148205735730754808467351639943474816280980230447097444682489223054499524197909719857300597157406075069204315022703894466226179507627070835428226086509767746759353822302809385047763292891543697277097068406512924796409393289982738071019047393972959228919115821862868057003145401072581115989680686073663259771587445250687060240991265143919857962047718344017741878925867800431556311785625469001771370852474292194

phi_n= (p-1) * (q-1)
def extended_gcd(a,b):
    if b==0:
        return a,1,0
    gcd,x1,y1=extended_gcd(b,a%b)
    x=y1
    y=x1-(a//b)*y1
    return gcd,x,y
gcd ,x ,y=extended_gcd(e,phi_n)

d=x%phi_n
print(f"d: {d}")
m=pow(c,d,p*q)
flag=long_to_bytes(m).decode()
print(f"flag: {flag}")
#flag: flag{b4by_R5A}
```

long_to_bytes 很好用哎

## easyrsa1

这个题目不给我 p,q，可以使用在线工具进行因式分解https://factordb.com/

```python
from Crypto.Util.number import long_to_bytes

e = 65537
c = 69380371057914246192606760686152233225659503366319332065009
n = 1455925529734358105461406532259911790807347616464991065301847
p=1201147059438530786835365194567
q=1212112637077862917192191913841


phi_n= (p-1) * (q-1)
def extended_gcd(a,b):
    if b==0:
        return a,1,0
    gcd,x1,y1=extended_gcd(b,a%b)
    x=y1
    y=x1-(a//b)*y1
    return gcd,x,y
gcd ,x ,y=extended_gcd(e,phi_n)

d=x%phi_n
print(f"d: {d}")
m=pow(c,d,p*q)
flag=long_to_bytes(m).decode()
print(f"flag: {flag}")
#flag{fact0r_sma11_N}
```

## easyrsa2

通过 ai 描述，这里可能是共素数攻击，比如说 n1,n2 共用一个 q，这个样子

那么可以有这样的解题思路

```text
已知：
	n1=p*q1
	n2=p*q2
那么，我们可以通过求解最大公因数拿到p
p=gcd(n1,n2)
q1=n1//p
q2=n2//p
```

> 这里的 math 库真好，直接有 gcd 可以让我用

```python
from math import gcd
from Crypto.Util.number import long_to_bytes
e = 65537
n1 = 23686563925537577753047229040754282953352221724154495390687358877775380147605152455537988563490716943872517593212858326146811511103311865753018329109314623702207073882884251372553225986112006827111351501044972239272200616871716325265416115038890805114829315111950319183189591283821793237999044427887934536835813526748759612963103377803089900662509399569819785571492828112437312659229879806168758843603248823629821851053775458651933952183988482163950039248487270453888288427540305542824179951734412044985364866532124803746008139763081886781361488304666575456680411806505094963425401175510416864929601220556158569443747
c1 = 1627484142237897613944607828268981193911417408064824540711945192035649088104133038147400224070588410335190662682231189997580084680424209495303078061205122848904648319219646588720994019249279863462981015329483724747823991513714172478886306703290044871781158393304147301058706003793357846922086994952763485999282741595204008663847963539422096343391464527068599046946279309037212859931303335507455146001390326550668531665493245293839009832468668390820282664984066399051403227990068032226382222173478078505888238749583237980643698405005689247922901342204142833875409505180847943212126302482358445768662608278731750064815

n2 = 22257605320525584078180889073523223973924192984353847137164605186956629675938929585386392327672065524338176402496414014083816446508860530887742583338880317478862512306633061601510404960095143941320847160562050524072860211772522478494742213643890027443992183362678970426046765630946644339093149139143388752794932806956589884503569175226850419271095336798456238899009883100793515744579945854481430194879360765346236418019384644095257242811629393164402498261066077339304875212250897918420427814000142751282805980632089867108525335488018940091698609890995252413007073725850396076272027183422297684667565712022199054289711
c2 = 2742600695441836559469553702831098375948641915409106976157840377978123912007398753623461112659796209918866985480471911393362797753624479537646802510420415039461832118018849030580675249817576926858363541683135777239322002741820145944286109172066259843766755795255913189902403644721138554935991439893850589677849639263080528599197595705927535430942463184891689410078059090474682694886420022230657661157993875931600932763824618773420077273617106297660195179922018875399174346863404710420166497017196424586116535915712965147141775026549870636328195690774259990189286665844641289108474834973710730426105047318959307995062

p=gcd(n1,n2)
q1=n1//p
q2=n2//p

phi1=(p-1)*(q1-1)
phi2=(p-1)*(q2-1)

d1=pow(e,-1,phi1)
d2=pow(e,-1,phi2)

m1=pow(c1,d1,n1)
m2=pow(c2,d2,n2)
print(long_to_bytes(m1))
print(long_to_bytes(m2))
#flag{m0_bv_hv_sv}
```

## easyrsa3

上面那个是共素数，这个题目是共模数

共模攻击的核心条件是：`gcd(e1,e2)=1`

因为：

- `c1 ≡ m^e1 (mod n)`
- `c2 ≡ m^e2 (mod n)`
- `gcd(792,521)=1 -> a*e1+b*e2=1`

所以就会存在

```latex
c1^a * c2^b ≡ m^(a*e1) * m^(b*e2) ≡ m^(a*e1 + b*e2) ≡ m^1 ≡ m (mod n)
```

exp 如下

```python
from math import gcd
from Crypto.Util.number import long_to_bytes

e1 = 797
c1 = 11157593264920825445770016357141996124368529899750745256684450189070288181107423044846165593218013465053839661401595417236657920874113839974471883493099846397002721270590059414981101686668721548330630468951353910564696445509556956955232059386625725883038103399028010566732074011325543650672982884236951904410141077728929261477083689095161596979213961494716637502980358298944316636829309169794324394742285175377601826473276006795072518510850734941703194417926566446980262512429590253643561098275852970461913026108090608491507300365391639081555316166526932233787566053827355349022396563769697278239577184503627244170930
e2 = 521
n = 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571
c2 = 6699274351853330023117840396450375948797682409595670560999898826038378040157859939888021861338431350172193961054314487476965030228381372659733197551597730394275360811462401853988404006922710039053586471244376282019487691307865741621991977539073601368892834227191286663809236586729196876277005838495318639365575638989137572792843310915220039476722684554553337116930323671829220528562573169295901496437858327730504992799753724465760161805820723578087668737581704682158991028502143744445435775458296907671407184921683317371216729214056381292474141668027801600327187443375858394577015394108813273774641427184411887546849

def extended_gcd(a,b):
    if b==0:
        return a,1,0
    g,x1,y1=extended_gcd(b,a%b)
    return g,y1,x1-(a//b)*y1

g,a,b=extended_gcd(e1,e2)

if a < 0:
    c1_inv=pow(c1,-1,n)
    m=(pow(c1_inv,-a,n)*pow(c2,b,n))%n
elif b < 0:
    c2_inv=pow(c2,-1,n)
    m=(pow(c1,a,n)*pow(c2_inv,-b,n))%n
else:
    m=(pow(c1,a,n)*pow(c2,b,n))%n
print(long_to_bytes(m))
#b'flag{sh4r3_N}'
```

### 负指数在模运算

数学原理：`负指数=模逆元`

在模 n 下

```plain
c^(-k) ≡ (c^(-1))^k (mod n)
```

这里 c^(-1)是 c 的模逆元，就是满足`c * c^(-1) ≡ 1 (mod n)`的数

在 python 中，一般这样求模逆元

```python
c_inv = pow(c, -1, n)  # 等价于 c^(phi(n)-1) mod n
```

下次遇到这样的题目，可以这样写脚本

```python
if a < 0:
    c1 = pow(c1, -1, n)  # c1变成c1的逆元
    a = -a               # a变成正数
elif b < 0:
    c2 = pow(c2, -1, n)
    b = -b

m = pow(c1, a, n) * pow(c2, b, n) % n
```

## easyrsa4

这个题目的特点是 e 特别小，只有 3,看 ai 的描述，应该考察的是小消息攻击

仔细观察数据，发现 n 特别特别大，我们可以轻松验证 m^e << n，那么这个 m^e 除以 n 的余数一定还是它本身，所以 c=m^3，这里和 n 没有啥关系了（压根没有触发模运算

这就意味着对 c 开立方可以直接获取 m，这是脚本

```python
import gmpy2
c = 150409620528139732054476072280993764527079006992643377862720337847060335153837950368208902491767027770946661
m = gmpy2.iroot(c, 3)
if m[1]:
    print(bytes.fromhex(hex(m[0])[2:]).decode())
#flag{Sm4ll_eee}
```

## easyrsa5

这个题感觉没有上面的难

先进行因式分解,成功了，下次不能再偷懒用 n//q 了，精度会损失

```python
from Crypto.Util.number import *

e = 284100478693161642327695712452505468891794410301906465434604643365855064101922252698327584524956955373553355814138784402605517536436009073372339264422522610010012877243630454889127160056358637599704871937659443985644871453345576728414422489075791739731547285138648307770775155312545928721094602949588237119345
n = 468459887279781789188886188573017406548524570309663876064881031936564733341508945283407498306248145591559137207097347130203582813352382018491852922849186827279111555223982032271701972642438224730082216672110316142528108239708171781850491578433309964093293907697072741538649347894863899103340030347858867705231
c = 350429162418561525458539070186062788413426454598897326594935655762503536409897624028778814302849485850451243934994919418665502401195173255808119461832488053305530748068788500746791135053620550583421369214031040191188956888321397450005528879987036183922578645840167009612661903399312419253694928377398939392827
p=18489327396055733397216193236128138397765028288613793035021305599301380136673327250408422592244732819005905679957567952974717041052102175277835219391448987
q=25336772790324258952117622504537139442881120269760383961991795601846585772802865528712760553670210656524156997774484665833049279421936394718949688217533213

phi=(p-1)*(q-1)
d=pow(e, -1, phi)
m=pow(c, d, n)
print(long_to_bytes(m))
#b'flag{very_biiiiig_e}'
```

## easyrsa6

这题我猜测是爆破查找两个相邻的大素数 p,q，但是我发现可以利用 factordb 直接分解出来，那么就正常计算即可

```python
from Crypto.Util.number import *

e = 0x10001
n = 26737417831000820542131903300607349805884383394154602685589253691058592906354935906805134188533804962897170211026684453428204518730064406526279112572388086653330354347467824800159214965211971007509161988095657918569122896402683130342348264873834798355125176339737540844380018932257326719850776549178097196650971801959829891897782953799819540258181186971887122329746532348310216818846497644520553218363336194855498009339838369114649453618101321999347367800581959933596734457081762378746706371599215668686459906553007018812297658015353803626409606707460210905216362646940355737679889912399014237502529373804288304270563
c = 18343406988553647441155363755415469675162952205929092244387144604220598930987120971635625205531679665588524624774972379282080365368504475385813836796957675346369136362299791881988434459126442243685599469468046961707420163849755187402196540739689823324440860766040276525600017446640429559755587590377841083082073283783044180553080312093936655426279610008234238497453986740658015049273023492032325305925499263982266317509342604959809805578180715819784421086649380350482836529047761222588878122181300629226379468397199620669975860711741390226214613560571952382040172091951384219283820044879575505273602318856695503917257
p=163515803000813412334620775647541652549604895368507102613553057136855632963322853570924931001138446030409251690646645635800254129997200577719209532684847732809399187385176309169421205833279943214621695444496660249881675974141488357432373412184140130503562295159152949524373214358417567189638680209172147385163
q=163515803000813412334620775647541652549604895368507102613553057136855632963322853570924931001138446030409251690646645635800254129997200577719209532684847732809399187385176309169421205833279943214621695444496660249881675974141488357432373412184140130503562295159152949524373214358417567189638680209172147385801

phi=(p-1)*(q-1)
d=pow(e, -1, phi)
m=pow(c, d, n)
print(long_to_bytes(m))
#b'flag{p&q_4re_t00_c1o5ed}'
```

这是相邻 p,q 爆破脚本

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

n = 26737417831000820542131903300607349805884383394154602685589253691058592906354935906805134188533804962897170211026684453428204518730064406526279112572388086653330354347467824800159214965211971007509161988095657918569122896402683130342348264873834798355125176339737540844380018932257326719850776549178097196650971801959829891897782953799819540258181186971887122329746532348310216818846497644520553218363336194855498009339838369114649453618101321999347367800581959933596734457081762378746706371599215668686459906553007018812297658015353803626409606707460210905216362646940355737679889912399014237502529373804288304270563
c = 18343406988553647441155363755415469675162952205929092244387144604220598930987120971635625205531679665588524624774972379282080365368504475385813836796957675346369136362299791881988434459126442243685599469468046961707420163849755187402196540739689823324440860766040276525600017446640429559755587590377841083082073283783044180553080312093936655426279610008234238497453986740658015049273023492032325305925499263982266317509342604959809805578180715819784421086649380350482836529047761222588878122181300629226379468397199620669975860711741390226214613560571952382040172091951384219283820044879575505273602318856695503917257

def fermat_factor(n):
    a = gmpy2.isqrt(n)
    if a * a < n:
        a += 1
    
    b2 = a * a - n
    while not gmpy2.is_square(b2):
        a += 1
        b2 = a * a - n
    
    b = gmpy2.isqrt(b2)
    p = a - b
    q = a + b
    return p, q

p, q = fermat_factor(n)
print(f"p = {p}")
print(f"q = {q}")
print(f"p * q == n: {p * q == n}")

phi = (p - 1) * (q - 1)
e = 0x10001
d = gmpy2.invert(e, phi)
m = pow(c, d, n)
flag = long_to_bytes(m)
print(flag)
```

算法原理如下

```plain
如果 n = p × q
那么存在两个数：
    a = (p + q)/2
    b = (q - p)/2

则：n = a² - b²
    → a² - n = b²
```

用 n=15 进行举例

- 取 a= ⌈√n⌉

  - ```plain
    √15 ≈ 3.87 → a = 4
    ```

- 计算 b² = a² - n

  - ```plain
    a = 4 → a² = 16
    b² = 16 - 15 = 1
    ```

- 检测 b²是否是完全平方数

  - ```plain
    √1 = 1 ✅ 是整数
    ```

- 计算 p,q

  - ```plain
    b = 1
    p = a - b = 4 - 1 = 3
    q = a + b = 4 + 1 = 5
    ```

就这样，可以轻松找到两个相邻的素数，回到我因式分解出来的两个素数，两个数字直接也就差距 638,所以 b=(q-p)/2=319

这意味着我们从 a = ⌈√n⌉开始，最多尝试 319 次就能成功找到 b²，整个时间复杂度最坏也就 O(319)

## easyrsa7

> 这题就是传说中的 RSA 高位已知攻击(**Coppersmith**)，之前看到就逃了，现在好好学下

首先分析下

题目给了`p_high = (p >> 128) << 128`  那么完整的`p=p_high+x`,x 就是未知的低 128bit

### Coppersmith 定理

> 知道 n = p × q，且知道 p 的高位（或低位），当未知比特数 ≤ n 比特数的 1/4 时，可以在多项式时间内恢复完整的 p

本题中 n 是 2048bit，p 是 1024bit，x 是 128bit，那么 128bit<2048/4=512bit，条件成立，可以尝试恢复

解题思路

```plain
p = p_high + x
x < 2^k  （k是未知位数）
需要解方程：(p_high + x) 能整除 n
这个方程可以借助LLL格基约化求解
```

- exp

```python
from Crypto.Util.number import long_to_bytes

n = 0x79e0bf9b916e59286163a1006f8cefd4c1b080387a6ddb98a3f3984569a4ebb48b22ac36dff7c98e4ebb90ffdd9c07f53a20946f57634fb01f4489fcfc8e402865e152820f3e2989d4f0b5ef1fb366f212e238881ea1da017f754d7840fc38236edba144674464b661d36cdaf52d1e5e7c3c21770c5461a7c1bc2db712a61d992ebc407738fc095cd8b6b64e7e532187b11bf78a8d3ddf52da6f6a67c7e88bef5563cac1e5ce115f3282d5ff9db02278859f63049d1b934d918f46353fea1651d96b2ddd874ec8f1e4b9d487d8849896d1c21fb64029f0d6f47e560555b009b96bfd558228929a6cdf3fb6d47a956829fb1e638fcc1bdfad4ec2c3590dea1ed3
c = 0x1b2b4f9afed5fb5f9876757e959c183c2381ca73514b1918d2f123e386bebe9832835350f17ac439ac570c9b2738f924ef49afea02922981fad702012d69ea3a3c7d1fc8efc80e541ca2622d7741090b9ccd590906ac273ffcc66a7b8c0d48b7d62d6cd6dd4cd75747c55aac28f8be3249eb255d8750482ebf492692121ab4b27b275a0f69b15baef20bf812f3cbf581786128b51694331be76f80d6fb1314d8b280eaa16c767821b9c2ba05dfde5451feef22ac3cb3dfbc88bc1501765506f0c05045184292a75c475486b680f726f44ef8ddfe3c48f75bb03c8d44198ac70e6b7c885f53000654db22c8cee8eb4f65eaeea2da13887aaf53d8c254d2945691
n_int = int(n)
p_high = 0xd1c520d9798f811e87f4ff406941958bab8fc24b19a32c3ad89b0b73258ed3541e9ca696fd98ce15255264c39ae8c6e8db5ee89993fa44459410d30a0a8af700ae3aee8a9a1d6094f8c757d3b79a8d1147e85be34fb260a970a52826c0a92b46cefb5dfaf2b5a31edf867f8d34d2222900000000000000000000000000000000

P.<x> = PolynomialRing(Zmod(n))
f = p_high + x
roots = f.small_roots(X=2**128, beta=0.4)  #用来找小根的

if roots:
    x0 = roots[0]
    p = int(p_high + x0)
    if n_int % p == 0:
        q = n_int // p
        e = 0x10001
        phi = (p-1)*(q-1)
        d = pow(e, -1, phi)
        m = pow(c, d, n_int)
        flag = long_to_bytes(int(m))
        print(f"Flag: {flag}")
     
 #Flag: b'flag{Kn0wn_Hi9h_Bit5}'
```

## easyrsa8

通过这个题，我理解了那些公钥的具体结构了

这里举个例子

```plain
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgTlUlVTKPIIMNZGz82fqFxZ3UlgR
vFSyYIPIHCJxfSzCsQncqlVyt5QiNoI8b0UhrZesJYexcMdmkb57/4OYKphkT8ok
5CFIOwE4CPE036NYe9OMh8e3uNp2VceEsF5C14m87sB4YmHe9qMGJwb9wjb9eA7s
7+h2HehtD5ZOUeHAEQIDAQAB
-----END PUBLIC KEY-----
```

可以借助 openssl 工具解开封装

```bash
yolo@Yolo /m/c/U/2/D/easyrsa8> openssl rsa -pubin -in public.key  -text -noout                                   (sage)
Public-Key: (1030 bit)
Modulus:
    39:54:95:54:ca:3c:82:0c:35:91:b3:f3:67:ea:17:
    16:77:52:58:11:bc:54:b2:60:83:c8:1c:22:71:7d:
    2c:c2:b1:09:dc:aa:55:72:b7:94:22:36:82:3c:6f:
    45:21:ad:97:ac:25:87:b1:70:c7:66:91:be:7b:ff:
    83:98:2a:98:64:4f:ca:24:e4:21:48:3b:01:38:08:
    f1:34:df:a3:58:7b:d3:8c:87:c7:b7:b8:da:76:55:
    c7:84:b0:5e:42:d7:89:bc:ee:c0:78:62:61:de:f6:
    a3:06:27:06:fd:c2:36:fd:78:0e:ec:ef:e8:76:1d:
    e8:6d:0f:96:4e:51:e1:c0:11
Exponent: 65537 (0x10001)
```

如果手动处理的话，我们需要先将上下的标签删除，然后删除换行符，进行 base64 解码，然后进行 hex 编码，可以拿到这样的信息

```plain
30 81 9f 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 03 81 8d 00 30 81 89 02 81 81 39 54 95 54 ca 3c 82 0c 35 91 b3 f3 67 ea 17 16 77 52 58 11 bc 54 b2 60 83 c8 1c 22 71 7d 2c c2 b1 09 dc aa 55 72 b7 94 22 36 82 3c 6f 45 21 ad 97 ac 25 87 b1 70 c7 66 91 be 7b ff 83 98 2a 98 64 4f ca 24 e4 21 48 3b 01 38 08 f1 34 df a3 58 7b d3 8c 87 c7 b7 b8 da 76 55 c7 84 b0 5e 42 d7 89 bc ee c0 78 62 61 de f6 a3 06 27 06 fd c2 36 fd 78 0e ec ef e8 76 1d e8 6d 0f 96 4e 51 e1 c0 11 02 03 01 00 01
```

这是给机器读的，用到了 ASN.1 标准

这里有个表格可以对照

| **十六进制片段**                   | **含义说明**                                                 |
| ---------------------------------- | ------------------------------------------------------------ |
| **`30 81 9f`**                     | **SEQUENCE**: 开启一个序列，长度为 0x9f (159 字节)。这是整个公钥的容器。 |
| `30 0d`                            | **SEQUENCE**: 内部小序列，记录算法标识。                     |
| `06 09 2a 86 48 86 f7 0d 01 01 01` | **OID**: 对象标识符，这里特指 `rsaEncryption`。              |
| `05 00`                            | **NULL**: 算法参数为空。                                     |
| **`03 81 8d 00`**                  | **BIT STRING**: 后面包裹的是密钥位串。                       |
| **`30 81 89`**                     | **SEQUENCE**: 进入真正的 RSA 核心：包含 $n$ 和 $e$ 的序列。  |
| **`02 81 81`**                     | **INTEGER (n)**: 声明接下来的 0x81 (129) 字节是模数 $n$。    |
| `39 54 95 ... c0 11`               | **Value of $n$**: 这就是你用 `openssl` 看到的那个超长数值。  |
| **`02 03`**                        | **INTEGER (e)**: 声明接下来的 0x03 字节是指数 $e$。          |
| `01 00 01`                         | **Value of $e$**: 转换成十进制就是 **65537**                 |

真的高级，综上，我们获取了 n 和 e

```python
n_hex="39549554ca3c820c3591b3f367ea171677525811bc54b26083c81c22717d2cc2b109dcaa5572b7942236823c6f4521ad97ac2587b170c76691be7bff83982a98644fca24e421483b013808f134dfa3587bd38c87c7b7b8da7655c784b05e42d789bceec0786261def6a3062706fdc236fd780eecefe8761de86d0f964e51e1c011"
n_decimal=int(n_hex,16)
print("n="n_decimal)
#n=10306247299477991196335954707897189353577589618180446614762218980226685668311143526740800444344046158260556585833057716406703213966249956775927205061731821632025483608182881492214855240841820024816859031176291364212054293818204399157346955465232586109199762630150640804366966946066155685218609638749171632685073
#e=0x10001
```

借助 factordb 工具，可以将 n 分解，获得

```plain
p=97
q=106249972159566919549855203174197828387397831115262336234662051342543151219702510584956705611794290291345944183845955839244363030579896461607496959399297130227066841321473005074379950936513608503266587950271044991876848389878395867601515004796212227929894460104645781488319246866661398816686697306692491058609
```

那么进行 rsa 解密

```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

n=10306247299477991196335954707897189353577589618180446614762218980226685668311143526740800444344046158260556585833057716406703213966249956775927205061731821632025483608182881492214855240841820024816859031176291364212054293818204399157346955465232586109199762630150640804366966946066155685218609638749171632685073
e=65537
p=97
q=106249972159566919549855203174197828387397831115262336234662051342543151219702510584956705611794290291345944183845955839244363030579896461607496959399297130227066841321473005074379950936513608503266587950271044991876848389878395867601515004796212227929894460104645781488319246866661398816686697306692491058609
phi=(p-1)*(q-1)
d=pow(e,-1,phi)
privatekey=RSA.construct((n,e,d,p,q))
rsa=PKCS1_OAEP.new(privatekey)
m=rsa.decrypt(open('flag.enc','rb').read())
print(m.decode())
#flag{p_1s_5mall_num6er}
```

这个题目有点特殊，就是那个密文还有层 pkcs1 填充，建议用 rsa 协议库进行解密处理，d 还是用到了的，只是我需要先重构成完整的私钥文件，然后才能解密

## funnyrsa1

这个题目的特点是：

- p1=p2
- e1,e2 不是质数

这是我的解题思路（哈哈，想起来当初入门 ctf 的时候，密码手告诉我，授课只要带两草稿纸就 ok 了

<img src="/img/ctfshow-shua-ti-xiao-ji-crypto.assets/36d2b2237080ca81b4e302c949f536a9_720.jpg" alt="36d2b2237080ca81b4e302c949f536a9_720" style="zoom:50%;" />

```python
#exp.sage
from Crypto.Util.number import long_to_bytes
e1 = 14606334023791426
p1 = 121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859
q1 = 130968576816900149996914427770826228884925960001279609559095138835900329492765336419489982304805369724685145941218640504262821549441728192761733409684831633194346504685627189375724517070780334885673563409259345291959439026700006694655545512308390416859315892447092639503318475587220630455745460309886030186593
c1 = 11402389955595766056824801105373550411371729054679429421548608725777586555536302409478824585455648944737304660137306241012321255955693234304201530700362069004620531537922710568821152217381257446478619320278993539785699090234418603086426252498046106436360959622415398647198014716351359752734123844386459925553497427680448633869522591650121047156082228109421246662020164222925272078687550896012363926358633323439494967417041681357707006545728719651494384317497942177993032739778398001952201667284323691607312819796036779374423837576479275454953999865750584684592993292347483309178232523897058253412878901324740104919248

e2 = 13813369129257838
p2 = 121009772735460235364940622989433807619211926015494087453674747614331295040063679722422298286549493698150690694965106103822315378461970129912436074962111424616439032849788953648286506433464358834178903821069564798378666159882090757625817745990230736982709059859613843100974349380542982235135982530318438330859
q2 = 94582257784130735233174402362819395926641026753071039760251190444144495369829487705195913337502962816079184062352678128843179586054535283861793827497892600954650126991213176547276006780610945133603745974181504975165082485845571788686928859549252522952174376071500707863379238688200493621993937563296490615649
c2 = 7984888899827615209197324489527982755561403577403539988687419233579203660429542197972867526015619223510964699107198708420785278262082902359114040327940253582108364104049849773108799812000586446829979564395322118616382603675257162995702363051699403525169767736410365076696890117813211614468971386159587698853722658492385717150691206731593509168262529568464496911821756352254486299361607604338523750318977620039669792468240086472218586697386948479265417452517073901655900118259488507311321060895347770921790483894095085039802955700146474474606794444308825840221205073230671387989412399673375520605000270180367035526919
phi1 = (p1-1)*(q1-1)
phi2 = (p2-1)*(q2-1)

b=gcd(e1,e2)

a1=e1//b
a2=e2//b

d1=pow(a1, -1, phi1)
d2=pow(a2, -1, phi2)

m1=pow(c1, d1, p1*q1)
m2=pow(c2, d2, p2*q2)

r1 = m1 % p1
r2 = m1 % q1
r3 = m2 % q2

x=crt([r1,r2,r3],[p1,q1,q2])

m=x.nth_root(b)
print(long_to_bytes(m))
#b"flag{gcd_e&\xcf\x86_isn't_1}"
```

## funnyrsa2

这题的特殊地方是 n=pqr,三个素数相乘，不过好在，这里的 n 可以使用 factordb 进行分解，再将 phi 按照欧拉函数多乘一个(r-1)即可

本题 exp

```python
# exp.sage
from Crypto.Util.number import long_to_bytes
n = 897607935780955837078784515115186203180822213482989041398073067996023639
c = 490571531583321382715358426750276448536961994273309958885670149895389968
e = 0x10001

p=876391552113414716726089
q=932470255754103340237147
r=1098382268985762240184333

phi = (p-1)*(q-1)*(r-1)
d=pow(e, -1, phi)

m=pow(c, d, n)
print(long_to_bytes(m))
#b'flag{what_that_fvck_r}'
```

## funnyrsa3

这个题目有点意思，给了 dp，dp 就是`d mod(p-1)`，dp 泄露的题目，做法一般是爆破处理，将 p 倒推出来,爆破的限制不多，只要保证是整数即可

<img src="/img/ctfshow-shua-ti-xiao-ji-crypto.assets/6bf2176d2b010149545cd0fe6da8e50f_720.jpg" alt="funnyrsa3" style="zoom:50%;" />



```python
#exp.sage
from Crypto.Util.number import long_to_bytes
e = 65537
n = 13851998696110232034312408768370264747862778787235362033287301947690834384177869107768578977872169953363148442670412868565346964490724532894099772144625540138618913694240688555684873934424471837897053658485573395777349902581306875149677867098014969597240339327588421766510008083189109825385296069501377605893298996953970043168244444585264894721914216744153344106498382558756181912535774309211692338879110643793628550244212618635476290699881188640645260075209594318725693972840846967120418641315829098807385382509029722923894508557890331485536938749583463709142484622852210528766911899504093351926912519458381934550361
dp = 100611735902103791101540576986246738909129436434351921338402204616138072968334504710528544150282236463859239501881283845616704984276951309172293190252510177093383836388627040387414351112878231476909883325883401542820439430154583554163420769232994455628864269732485342860663552714235811175102557578574454173473
c = 6181444980714386809771037400474840421684417066099228619603249443862056564342775884427843519992558503521271217237572084931179577274213056759651748072521423406391343404390036640425926587772914253834826777952428924120724879097154106281898045222573790203042535146780386650453819006195025203611969467741808115336980555931965932953399428393416196507391201647015490298928857521725626891994892890499900822051002774649242597456942480104711177604984775375394980504583557491508969320498603227402590571065045541654263605281038512927133012338467311855856106905424708532806690350246294477230699496179884682385040569548652234893413

for k in range(1,e):
    if (e*dp-1) % k == 0:
        p=(e*dp-1) // k + 1
        if n % p == 0:
            q=n//p
            break
phi=(p-1)*(q-1)
d=pow(e,-1,phi)
m=pow(c,d,n)
print(long_to_bytes(m))
#b'flag{dp_i5_1eak}'
```

## unusualrsa1

哇，这题难度一下上来了，仔细观察，发现 e=3 是很低的指数了，然后 m 的高位被泄露了，可以联系上面 easyrsa7 用到的 Coppersmith 算法解决

> 通过 ai 学会了这个题的做法，不得不惊叹，这个和 zip 压缩包的明文攻击有点像，因为都没有求解私钥 d，通过固定已知明文能直接绕过，天呐，好有缘分

```python
#exp.sage
from Crypto.Util.number import long_to_bytes
n=14113948189208713011909396304970377626324044633561155020366406284451614054260708934598840781397326960921718892801653205159753091559901114082556464576477585198060530094478860626532455065960136263963965819002575418616768412539016154873800614138683106056209070597212668250136909436974469812231498651367459717175769611385545792201291192023843434476550550829737236225181770896867698281325858412643953550465132756142888893550007041167700300621499970661661288422834479368072744930285128061160879720771910458653611076539210357701565156322144818787619821653007453741709031635862923191561438148729294430924288173571196757351837
m_high=1520800285708753284739523608878585974609134243280728660335545667177630830064371336150456537012842986526527904043383436211487979254140749228004148347597566264500276581990635110200009305900689510908049771218073767918907869112593870878204145615928290375086195098919355531430003571366638390993296583488184959318678321571278510231561645872308920917404996519309473979203661442792048291421574603018835698487725981963573816645574675640357569465990665689618997534740389987351864738104038598104713275375385003471306823348792559733332094774873827383320058176803218213042061965933143968710199376164960850951030741280074168795136
c=6635663565033382363211849843446648120305449056573116171933923595209656581213410699649926913276685818674688954045817246263487415328838542489103709103428412175252447323358040041217431171817865818374522191881448865227314554997131690963910348820833080760482835650538394814181656599175839964284713498394589419605748581347163389157651739759144560719049281761889094518791244702056048080280278984031050608249265997808217512349309696532160108250480622956599732443714546043439089844571655280770141647694859907985919056009576606333143546094941635324929407538860140272562570973340199814409134962729885962133342668270226853146819

k=315
X=2^k

PR.<x>=PolynomialRing(Zmod(n))
f=(m_high+x)^3-c
roots=f.small_roots(X=X,beta=0.5)
root=roots[0]
m=(m_high+root)
print(long_to_bytes(int(m)))
#b'\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0cflag{r54__c0pp3r5m17h_p4r714l_m_4774ck_15_c00l~}'
```

## unusualrsa2

这题特殊的地方是，又引进了 x,y 两个未知数序列

```python
reduce(lambda x,y:x&y,[(i-5)*i+6==0 for i in x])
```

- 对每个 i 计算(i-5)*i+6 是否等于 0，稍微化简下(i-2)(i-3)=0,所以每个 i 都是 2 或 3
- reduce 是让所有元素都满足上述情况
- 可以确定 x=[2 或 3,2 或 3,...]这个序列的长度未知，但是可以确定元素是 2 或 3

```python
reduce(lambda x,y:x&y,[(j-15)*j+44==0 for j in y])
```

- 对每个 j 进行计算(j-15)j+44=0,解方程，求得 j=11 或 4
- 那么就确定 y=[11 或 4,11 或 4,...]和上面的 x 序列的情况差不多

```python
print(pow(reduce(lambda x,y:x*m+y,x),17,n))
print(pow(reduce(lambda x,y:x*m+y,y),17,n))
```

- `reduce(lambda x,y: x*m+y,x)`作用

  - 假设 x=[i1,i2,i3]
  - `result=((i1*m+i2)*m+i3)...`
  - 本质上就是将原来的整数数组编码成一个大整数，类似 m 进制编码，每个元素作为一位

  `pow(...,17,n)`：指数 17 后`mod n`

通过上面的分析，emm，可以观察到，这里 m 进制展开的话，理论一定可以整理成 m*(...)+x，那么！我们是不是可以同时构造两个式子？寻找两个式子在多项环中的的 gcd，就可以找到我们需要的 m

但是 m 的范围不好确定，留意到假如设`M1=2m+3,M2=4m+11`,那么一定存在`M2=2(2m+3)+5=2M1+5`，可以构造线性关系

> but，这里有点点牵强，正式比赛的时候只能做这种尝试，因为如果让 x=[2,2,2,2,...],y=[11,4,11,4,4,11,...]，额，无法建立线性关系，分类讨论吧，但事实证明，本题可以大胆往线性关系上面凑

本题的解决方法有个名称：Franklin-Reiter 攻击（因为是他们两提出来的

---

我们现在有两个密文：

- C1≡M1^17(modn)
- C2≡(2M1+5)^17(modn)

在多项式环 Zn[X]中，我们可以定义两个多项式：

- f1(X)=X^17-C1
- f2(X)=(2X+5)^17-C2

很显然，M1 是这两个多项式在模 n 下的共同根，通过计算两个多项式的 GCD，可以直接提取线性因子(X-M1),从而求得 M1

```python
#exp.sage
from Crypto.Util.number import long_to_bytes, inverse
n = 23772599983135215481563178266884362291876571759991288577057472733374903836591330410574958472090396886895304944176208711481780781286891334062794555288959410390926474473859289842654809538435377431088422352076225067494924657598298955407771484146155998883073439266427190212827600119365643065276814044272790573450938596830336430371987561905132579730619341196199420897034988685012777895002554746080384319298123154671447844799088258541911028041717897434816921424155687677867019535399434825468160227242441375503664915265223696139025407768146464383537556265875013085702422829200814612395116961538432886116917063119749068212699
c1 = 10900151504654409767059699202929100225155892269473271859207513720755903691031362539478242920144073599515746938827937863835169270383721094542639011665235593065932998091574636525973099426040452626893461449084383663453549354608769727777329036059746386523843912382289597182615339786437186169811342356085836838520978047561127661777189045888648773949147220411427306098338616422692914110656004863767719312410906124366000507952960331116878197129010412361636679449281808407214524741732730279777729251515759320442591663641984363061618865267606007355576230009922421807527598213455112981354590909603317525854070358390622096569841
c2 = 17298679220717326374674940612143058330715465693318467692839033642321129433471254547497087746971317567301086124779289015934582615377165560688447452762043163082394944604062014490446763247008217251611443338103074143809936437694543761369945095202092750900940979469994907399829695696313513303922266742415376818434932335640062684245008822643258497589196668426788916969378417960200705779461808292296450298558001909603602502604228973101048082095642290047196235959438278631661658312398313171590515776453711432353011579809351076532129444735206408591345372296372378396539831385036814349328459266432393612919118094115543053115450
e = 17

PR.<X> = PolynomialRing(Zmod(n))

f1 = X^e - c1
f2 = (2*X + 5)^e - c2

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a.monic()
res = gcd(f1, f2) #这里拿到的是多项式，并不是一个数
m1 = n - res.coefficients()[0] #coefficients拿的是常数项，然后因为全局要在模n下运算，所以用n减去这个数就得到了m1
m = ((m1 - 3) * inverse(2, n)) % n
print(long_to_bytes(int(m)))
#b'flag{r54__r3l473d_m355463_4774ck_4l50_c4ll3d_fr4nkl1n_r3173r_4774ck~}'
```













